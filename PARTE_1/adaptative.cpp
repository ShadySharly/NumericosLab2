////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////// PART 1 /////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////// PRE-COMPILATION DIRECTIVES  //////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <iostream>
#include <fstream>
#include <string>
#include <armadillo>
#include <vector>
#include "unistd.h"

using namespace std;
using namespace arma;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////// DECLARATIONS //////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

long double adaptativeTrapeze(long double a, long double b, long double tol, int &iterations);

long double adaptativeOneThird (long double a, long double b, long double tol, int &iterations);

long double adaptativeThreeHeighths (long double a, long double b, long double tol, int &iterations);

long double applyFunction (long double x);

long double trapeze (long double a, long double b);

long double oneThird (long double a, long double b);

long double threeEighths (long double a, long double b);

int main (int argc, char *const *argv);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////// PRINCIPAL FUNCTIONS  //////////////////////////////////////////////////////-///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// - INPUTS: - a: Cota inferior del intervalo
//           - b: Cota superior del intervalo
//			 - tol: Tolerancia ingresada por el usuario
//		     - iterations: COntador del numero de iteraciones del metodo
// - OUTPUTS: Devuelve el resultado del Metodo del Trapecio Simple Adaptativo
// - DESCRIPTION: Implementacion del metodo del Trapecio Simple Adaptativo, utilizando recursion arborea

long double adaptativeTrapeze(long double a, long double b, long double tol, int &iterations) {

	long double m, error, integral;

	m = (a + b) / 2.0;
	integral = trapeze (a, b);
	error = abs (integral - (trapeze(a, m) + trapeze(m, b)));
	iterations++;

    // Condicion de parada
	if(error < tol)
		return trapeze(a, m) + trapeze(m, b);
	
    // Llamada recursiva
	else
		return adaptativeTrapeze (a, m, tol, iterations) + adaptativeTrapeze(m, b, tol, iterations);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// - INPUTS: - a: Cota inferior del intervalo
//           - b: Cota superior del intervalo
//			 - tol: Tolerancia ingresada por el usuario
//		     - iterations: COntador del numero de iteraciones del metodo
// - OUTPUTS: Devuelve el resultado del Metodo de Simpson Un Tercio Adaptativo
// - DESCRIPTION: Implementacion del metodo de Simpson Un Tercio Adaptativo, utilizando recursion arborea

long double adaptativeOneThird (long double a, long double b, long double tol, int &iterations) {

	long double m, error, integral;

	m = (a + b) / 2.0;
	integral = oneThird(a,b);
	error = abs (integral - (oneThird(a,m) + oneThird(m,b)));
	iterations++;

	// Condicion de parada
	if(error < tol)
		return oneThird(a, m) + oneThird(m, b);
	
	// Llamada recursiva
	else
		return adaptativeOneThird(a, m, tol, iterations) + adaptativeOneThird(m, b, tol, iterations);
	
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// - INPUTS: - a: Cota inferior del intervalo
//           - b: Cota superior del intervalo
//			 - tol: Tolerancia ingresada por el usuario
//		     - iterations: COntador del numero de iteraciones del metodo
// - OUTPUTS: Devuelve el resultado del Metodo de Simpson Tres Octavos Adaptativo
// - DESCRIPTION: Implementacion del metodo de Simpson Tres Octavos Adaptativo, utilizando recursion arborea

long double adaptativeThreeHeighths (long double a, long double b, long double tol, int &iterations) {

	long double m, error, integral;

	m = (a + b) / 2.0;
	integral = threeEighths(a, b);
	error = abs (integral - (threeEighths(a, m) + threeEighths(m, b)));
	iterations++;

	// Condicion de parada
	if(error < tol)
		return threeEighths(a, m) + threeEighths(m, b);
	
	// Llamada recursiva
	else
		return adaptativeThreeHeighths(a, m, tol, iterations) + adaptativeThreeHeighths(m, b, tol, iterations);
	
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////// COMPLEMENTARY FUNCTIONS  ////////////////////////////////////////////////////-///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// - INPUTS: - x: Parametro de entrada de la funcion
// - OUTPUTS: Devuelve la evaluacion del parametro de entrada x en la funcion
// - DESCRIPTION: A partir de un numero de entrada "x", lo evalua dentro de la funcion "2^x - 16x"

long double applyFunction (long double x) {

	long double y;
	y = pow(2, x);
	y = y - 16 * x;

	return y;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// - INPUTS: - a: Cota inferior del intervalo
//           - b: Cota superior del intervalo
// - OUTPUTS: Devuelve el resultado del metodo del trapecio simple
// - DESCRIPTION: Implementacion del metodo del Trapecio Simple

long double trapeze (long double a, long double b) {

    long double y;
    y = (b - a) ;
	y = y * (applyFunction(a) + applyFunction(b)) / 2.0;

	return y;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// - INPUTS: - a: Cota inferior del intervalo
//           - b: Cota superior del intervalo
// - OUTPUTS: Devuelve el resultado del metodo de Simpson Un Tercio
// - DESCRIPTION: Implementacion del metodo de Simpson Un Tercio

long double oneThird (long double a, long double b) {

	long double Fa, Fb, Fm, m, h, simpson;

	m = (a + b) / 2.0;
	h = (b - a) / 6.0;
	Fa = applyFunction(a);
	Fb = applyFunction(b);
	Fm = applyFunction(m);

	simpson = h * (Fa + Fb + 4 * Fm);

	return simpson;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// - INPUTS: - a: Cota inferior del intervalo
//           - b: Cota superior del intervalo
// - OUTPUTS: Devuelve el resultado del metodo de Simpson Tres Octavos
// - DESCRIPTION: Implementacion del metodo de Simpson Tres Octavos

long double threeEighths (long double a, long double b) {

	long double x1,x2,Fa,Fb,Fx1,Fx2,h, simpson;

	h = (b - a) / 3.0;
	x1 = a + h;
	x2 = x1 + h;
	Fa = applyFunction(a);
	Fb = applyFunction(b);
	Fx1 = applyFunction(x1);
	Fx2 = applyFunction(x2);

	simpson = (3 * h / 8) * (Fa + 3 * Fx1 + 3 * Fx2 + Fb);

	return simpson;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////// MAIN ////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int main(int argc, char *const *argv) {

	long double a, b, tol;
	int c, iterations;
	string method;
	iterations = 0;

	while( (c = getopt(argc, argv, "t:a:b:I: ")) != -1) {

      	switch(c){
			  
			case 't':
				tol = atof(optarg);
				break;

			case 'a':
				a = atof(optarg);
				break;

			case 'b':
				b = atof(optarg);
				break;

			case 'I':
				method= optarg;
				break;

			case '?':
				printf("OpciÃ³n desconocida: %c\n",c);

			default:
				printf("Parametros mal ingresados\n");

			return 1;
      	}
  	}

	// Ejecucion del Metodo del Trapecio Adaptativo
  	if(method == "trap" ) {
		cout << "Resultado Trapecio Adaptativo: "<< adaptativeTrapeze (a, b, tol, iterations) <<endl;
		cout << "Iteraciones Trapecio Adaptativo: "<< iterations<<endl;
	}

	// Ejecucion del Metodo de Simpson Un Tercio Adaptativo
	else if (method == "sim3"){
		cout << "Resultado Simpson Un Tercio Adaptativo: " << adaptativeOneThird (a, b, tol, iterations) <<endl;
		cout << "Iteraciones Simpson Un Tercio Adaptativo: "<< iterations << endl;
	}

	// Ejecucion del Metodo de Simpson Tres Octavos Adaptativo
	else if (method == "sim8"){
		cout << "Resultado Simpson Tres Octavos Adaptativo: "<<adaptativeThreeHeighths (a,b,tol,iterations) <<endl;
		cout << "Iteraciones Simpson Tres Octavos Adaptativo: "<< iterations << endl;
	}

	return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////